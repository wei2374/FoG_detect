#R1.1 What are decoupling capacitors? Please explain in detail why they are needed in circuits with MCUs.
* Decoupling capacitors are capacitors used to decouple part of electrical circuit from other parts of the circuit;
* We use them because of two reasons : 
	1. To reduce the noise signal inteference from other part of circuits
	2. To gurarantee more stable power supply and sink the peak current generated by impedance;

#R1.2 What properties are important for good decoupling capacitors. Name at least two and explain.

1. Capacitor value (C) needs to be big enough such that the voltage drop is small when there is a change for current supply.

2. They size of capacitor is also important since they need to be put as close as possible to devices to reduce additional resistance and impedance of wiring.

#R1.3 Where would you place decoupling capacitors in a PCB layout. Explain why you would place them there.

* They need to be put between ground line and power line, since they are used to stable the powersupply, also they need to be near the device as close as possible to avoid additional parasitic resistance and impedance.



#R3.1 
* We can change the value of a r18 in one cycle and give the value to PORTC in one instruction in one cycle; PC0 and PC0 to high while PC2 and PC3 to 3 can be interprets as 0011 in the last 4 bits, we can use it to or the original PORTC value.
	in r18,PORTC;
	ori r18, 0x03;
	out PORTC,r18;


#R3.2
* I don't think it is possible to set 2 pins of 2 different ports at the same time. Because the logic level for PORTB and PORTC pins for example are controlled by the content of different registers and it is not possible to change the content of two registers with one instruction.

	
#R3.3
* 
	// wait for one second
	//load immediate number 0x3F to general register r18
1	 ldi r18, 0x3F
	//load immediate number 0x0D to general register r25
2	 ldi r24, 0x0D
	//load immediate number 0x03 to general register r25
3	 ldi r25, 0x03

	//substract an immediate number 0x01 from r18 and update C flag if need
4	 1: subi r18, 0x01
	//substract carry flag if it is 1 while substracting an immediate number 0 only update C flag if it is 1 
5	 sbci r24, 0x00
	//substract carry flag if it is 1 while substracting an immediate number 0 only update C falg is it is 1 
6	 sbci r25, 0x00
	//if zero flag is not set, when r18 and r24 and r25 is not 0, loop backwards, otherwise break out the loop	
7	 brne 1b ; local label backward
8	 rjmp 1f ; local label forward

9	 1: nop

#R3.4
	*The number in 3 registers are 0x3F,0x0D,0x03; If we combine them into a 24 bits number, it becomes 0x3F0D03, and it is 199999. And in this implementation of one second delay we are just reducing it from 199999 to 1, each reduction takes 5 cycles, which makes 199999*5 cycles(subi,sbci,sbci,and brne which takes 2 cycles). Additionally we have 3 ldi instruction and one rjmp and one nop. These whole combines together makes 1000000 cycles,and this gives us 1s;

#R3.5
	* With busy waiting, the CPU is always doing the counting job and this wasts its function as a resource, no other functions can be executed.

	* With bust waiting, the CPU cannot put itself to a sleep so it is power ineffecient.

#R3.6
* If an interrupt happens the code will goes to an ISR and return after finishes the ISR, then several more codes are executed and the execution time will be longer. This piece of code cannot guarantee 1 second time length.

#R3.7
* Data and registers use different physical implementation and they have different access speed and differnt method to access. ST/LD take 2 cycles to finish while IN/OUT only take one;

#R3.8
* mov r18, 0xAC;
  out PORTD,r18;

* mov XH, 0x00;
  mov XL, 0x12;
  mov r18, 0xAC;
  st X,r18;

#R3.9
* it takes 2 cycles using out 
* it takes 5 cycles using st

#R3.10
* In C language to read/write to a register can think as read/write to a memory address. The register with address 0x15 is PORTC and it has eight bits. So we can use the following code to do this:

	uint8_t* addr = 0x15;
	*(addr) = value_to_write;
	value_to_read = *(addr);

#R4.1 
* According to the formula in datasheet, the baudrate equals to frequency of system oscillator divid by 16 multiply the sum of content in UBRR register plus 1;
Generally speaking the UBRR like a count down timer, whenever its value equals to 0 a clock signal is generated. Since we used double transmission speed flag, the clock is further downscalar 16 times.

* The baudrate error is 0 when the baudrate is 62500 Baud.

#R4.2
* The CPU frequency is limited, so to achieve high transmission speed  we need a fast root clock; We can improve the CPU frequency to improve baudrate
* The baudrate needs to be configured so that there should be as smaller error as possible, which means it should close to the value which can be prescaled with UBRR and certain mode. It can be mitigated if it has a clock itself.

#R4.3
* The baudrate 38400 cannot be achieved with our configuration since the error rate is -18.6 percent. So there will be too much difference between each bits and the receiver cannot sample and receive each bits correctly.

#R4.4
* We can change the CPU frequency to 1.8432MHz and change UBRR content to 2, then we can have 0 percent error.


#R5.1
* I save the register SREG by first putting its content into a general purpose register and the push it into the stack;

#R5.2
* I need to save the register SREG whenever I need a function call, I can either save it before the function call and restore it after function call. Or I can push it into stack in the function call and restore it by popping before return

#R5.3
* I need to save the SREG in the implementation, since the carry flag actually plays a role in the implementation of 512 bit adder function and I need to initialize it to 0 before the function code. So I need to remember the original status of C flag and restore it after the function code.

#R5.4
* I think learning assembly code allows us to debug in a deeper level.
* Assemble coding enables us to do more efficient implementation.
* It can tell us the limitation on low level.

#R5.5
* It is preferable to use assembly code when a piece of code need to be optimized and the compiler is not good enough. 
* To do stack buffer overflow, we need to find some gadget in the assembly code.
* It is preferable to use assembly code when you can figure out a more efficient implementation than C compiler. And when you want to do buffer overflow attack you need to know and use assembly.

#R5.6
* assembly is low-level and is depend on hardware instruction set, so the same code of assembly cannot run on different hardware platforms ;
* assembly is harder to debug and more verbose than C.

#R5.7
* C is easier to debug 
* with the help of compilers, same C code can run on different platforms;

#R5.8
* multiply a and b,  a and b are all 512 bits, result is a 1024 bits number c;
* since I will use r17, first push it and SREG on the stack
* initialize c as 0
* loop 2
* loop 1 
* put the first 8 bits of a with first 8 bits of b into r18 and r19
* mul r18,r19
* store r19 into first 8 bits of c, 
* mov r17,r18
* take the next 8 bits of a and first 8 bits of b to r18 and r19
* mul r18,r19
* add r19,r17 //add the carry numbers from lower part
* loop 1, until all 8 bits of a is multiplied with first 8 bits 
* take next 8 bits of b and multiply it with a again, shift the result to left accordingly and add it with c(1024 bits add)
* loop 2, until all 64 8 bits of b is multiply with a
* get c 

#R5.9
* loop1 we have 64 8bits multiplication , loop2 has 64 loop1, so in total we have 4096 8 bits multiplication.

